 def powerfulInteger(self, intervals, k):
        # algorithm sort the entire events based on the time
        # record the active interval.
        # if the active interval count >= k, then before
        # pop the end time, it should be best so far
        
        events = []
        for start, end in intervals:
            # make start type as -1 so that it will 
            # appear before end time if they are equal
            events.extend([(start, -1), (end, 1)])
        events.sort()
        #print(events)
        cnt, ans = 0, -1
        for t, typ in events:
            if typ == -1:
                cnt += 1 #increment 1 for active interval cnt
            else:
                if cnt >= k: # before decrement active interval cnt, 
                             # do test because current end time is still active
                    ans = max(ans, t)
                cnt -= 1
        return ans
        
